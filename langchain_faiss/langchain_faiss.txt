import os
import json
import time
import logging
from logging.handlers import RotatingFileHandler
from typing import List

from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel

# --------------------------
# LOGGING (FILE + CONSOLE)
# --------------------------

# Create logs directory
if not os.path.exists("logs"):
    os.makedirs("logs")

# Log Formatter
formatter = logging.Formatter(
    "%(asctime)s | %(levelname)s | %(message)s"
)

# File handler ‚Üí rotates at 5 MB, keeps last 3 files
file_handler = RotatingFileHandler(
    "logs/rag_fast.log",
    maxBytes=5_000_000,
    backupCount=3,
    encoding="utf-8"
)
file_handler.setFormatter(formatter)
file_handler.setLevel(logging.INFO)

# Console handler
console_handler = logging.StreamHandler()
console_handler.setFormatter(formatter)
console_handler.setLevel(logging.INFO)

# Logger
log = logging.getLogger("rag-fast")
log.setLevel(logging.INFO)
log.addHandler(file_handler)
log.addHandler(console_handler)

# --------------------------
# FASTAPI SETUP
# --------------------------

app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)

# --------------------------
# LANGCHAIN IMPORTS
# --------------------------

from langchain_google_genai import GoogleGenerativeAI
from langchain_google_genai import GoogleGenerativeAIEmbeddings
from langchain_community.vectorstores import FAISS

from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain.document_loaders import PyPDFLoader, TextLoader

GEMINI_API_KEY = "AIzaSyBkjXLcA-_4FNgjXf_CBgGjC1lHf3YID8o"

# Global holders
vector_store = None
llm_fast = None

# --------------------------
# MODELS
# --------------------------

class QuizRequest(BaseModel):
    topic: str
    difficulty: str

class Answer(BaseModel):
    selected: str
    correct: str

class ScoreRequest(BaseModel):
    answers: List[Answer]

# --------------------------
# CLEAN JSON
# --------------------------

def clean_json(txt):
    txt = txt.replace("```json", "").replace("```", "").strip()
    try:
        return json.loads(txt)
    except:
        if "[" in txt and "]" in txt:
            try:
                sub = txt[txt.index("["): txt.rindex("]") + 1]
                return json.loads(sub)
            except:
                pass
        return None

# --------------------------
# FAST LLM CALL
# --------------------------

async def llm_call_fast(prompt: str):
    global llm_fast

    if llm_fast is None:
        llm_fast = GoogleGenerativeAI(
            model="gemini-2.5-flash",
            google_api_key=GEMINI_API_KEY
        )

    start = time.perf_counter()
    res = await llm_fast.ainvoke(prompt)
    duration = round(time.perf_counter() - start, 4)
    log.info(f"‚ö° FAST LLM Time: {duration} sec")
    return res

# --------------------------
# STARTUP ‚Üí BUILD FAISS
# --------------------------

@app.on_event("startup")
async def startup_event():
    global vector_store

    try:
        log.info("üìÇ Loading documents from /pdfs ...")

        if not os.path.exists("pdfs"):
            os.makedirs("pdfs")

        docs = []

        for file in os.listdir("pdfs"):
            path = os.path.join("pdfs", file)
            if file.endswith(".pdf"):
                loader = PyPDFLoader(path)
                docs.extend(loader.load())
            elif file.endswith(".txt"):
                loader = TextLoader(path)
                docs.extend(loader.load())

        log.info(f"üìÑ Loaded {len(docs)} files")

        # Text splitting
        splitter = RecursiveCharacterTextSplitter(
            chunk_size=1200,
            chunk_overlap=100
        )
        split_docs = splitter.split_documents(docs)

        log.info(f"üß© Split into {len(split_docs)} chunks")

        embed = GoogleGenerativeAIEmbeddings(
            model="models/text-embedding-004",
            google_api_key=GEMINI_API_KEY
        )

        start = time.perf_counter()

        vector_store = FAISS.from_documents(
            split_docs,
            embedding=embed
        )

        duration = round(time.perf_counter() - start, 4)
        log.info(f"üîê FAISS built in {duration} sec")
        log.info("‚ú® FAST RAG Engine Ready (LangChain + FAISS)")

    except Exception as e:
        log.error("Fatal startup error:", exc_info=True)
        raise

# --------------------------
# GET TOPICS
# --------------------------

@app.get("/topics")
async def get_topics():
    prompt = """
    Return a JSON array of chemistry topics.
    Example: ["Organic Chemistry", "Inorganic Chemistry"]
    """

    try:
        raw = await llm_call_fast(prompt)
        data = clean_json(raw)

        if data:
            return {"topics": data}

        return {"topics": ["Fallback Topic"]}

    except Exception as e:
        log.error("Topic retrieval error:", exc_info=True)
        return {"topics": ["Fallback Topic"]}

# --------------------------
# GENERATE QUIZ
# --------------------------

@app.post("/start_quiz")
async def start_quiz(req: QuizRequest):
    global vector_store

    try:
        retriever = vector_store.as_retriever(search_kwargs={"k": 5})

        start_ret = time.perf_counter()
        nodes = retriever.get_relevant_documents(req.topic)
        retrieval_time = round(time.perf_counter() - start_ret, 4)

        log.info(f"üîé RAG Retrieval Time: {retrieval_time} sec")
        log.info(f"üìö Retrieved {len(nodes)} chunks")

    except Exception:
        nodes = []
        retrieval_time = None

    context = "\n\n".join([n.page_content for n in nodes])

    prompt = f"""
    Generate 10 MCQ questions in JSON format.

    Topic: "{req.topic}"
    Difficulty: "{req.difficulty}"

    Context:
    {context}

    Format:
    [
        {{"q": "...", "A": "...", "B": "...", "C": "...", "D": "...", "correct": "A"}}
    ]
    """

    try:
        raw = await llm_call_fast(prompt)
        quiz = clean_json(raw)

        if quiz and len(quiz) == 10:
            return {"quiz": quiz, "retrieval_time": retrieval_time}

        raise HTTPException(status_code=500, detail="Invalid quiz JSON")

    except Exception as e:
        log.error("Quiz error:", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))

# --------------------------
# SCORE
# --------------------------

@app.post("/final_score")
async def final_score(req: ScoreRequest):
    score = sum(1 for x in req.answers if x.selected == x.correct)
    return {"score": score, "total": len(req.answers)}